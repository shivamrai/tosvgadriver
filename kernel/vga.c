#include <kernel.h>
#include <vga.h>
/** Global constants
 * MAX_WINDOWS is for managing max windows on the screen, currently limited to 10.
 **/
#define MAX_WINDOWS 10

/**
 * Charset taken from https://github.com/dhepper/font8x8
 * 8x8 monochrome bitmap font for rendering.
 * Author: Marcel Sondaar (International Business Machines (public domain VGA fonts)).
 * License: Public Domain
 * Every character in the font is encoded row-wise in 8 bytes.
 * The least significant bit of each byte corresponds to the first pixel in a row.
 **/
char font8x8_basic[128][8] = {
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0000 (nul)
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0001
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0002
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0003
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0004
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0005
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0006
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0007
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0008
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0009
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+000A
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+000B
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+000C
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+000D
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+000E
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+000F
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0010
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0011
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0012
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0013
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0014
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0015
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0016
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0017
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0018
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0019
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+001A
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+001B
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+001C
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+001D
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+001E
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+001F
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0020 (space)
    { 0x18, 0x3C, 0x3C, 0x18, 0x18, 0x00, 0x18, 0x00},   // U+0021 (!)
    { 0x36, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0022 (")
    { 0x36, 0x36, 0x7F, 0x36, 0x7F, 0x36, 0x36, 0x00},   // U+0023 (#)
    { 0x0C, 0x3E, 0x03, 0x1E, 0x30, 0x1F, 0x0C, 0x00},   // U+0024 ($)
    { 0x00, 0x63, 0x33, 0x18, 0x0C, 0x66, 0x63, 0x00},   // U+0025 (%)
    { 0x1C, 0x36, 0x1C, 0x6E, 0x3B, 0x33, 0x6E, 0x00},   // U+0026 (&)
    { 0x06, 0x06, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0027 (')
    { 0x18, 0x0C, 0x06, 0x06, 0x06, 0x0C, 0x18, 0x00},   // U+0028 (()
    { 0x06, 0x0C, 0x18, 0x18, 0x18, 0x0C, 0x06, 0x00},   // U+0029 ())
    { 0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00},   // U+002A (*)
    { 0x00, 0x0C, 0x0C, 0x3F, 0x0C, 0x0C, 0x00, 0x00},   // U+002B (+)
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x06},   // U+002C (,)
    { 0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x00},   // U+002D (-)
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x00},   // U+002E (.)
    { 0x60, 0x30, 0x18, 0x0C, 0x06, 0x03, 0x01, 0x00},   // U+002F (/)
    { 0x3E, 0x63, 0x73, 0x7B, 0x6F, 0x67, 0x3E, 0x00},   // U+0030 (0)
    { 0x0C, 0x0E, 0x0C, 0x0C, 0x0C, 0x0C, 0x3F, 0x00},   // U+0031 (1)
    { 0x1E, 0x33, 0x30, 0x1C, 0x06, 0x33, 0x3F, 0x00},   // U+0032 (2)
    { 0x1E, 0x33, 0x30, 0x1C, 0x30, 0x33, 0x1E, 0x00},   // U+0033 (3)
    { 0x38, 0x3C, 0x36, 0x33, 0x7F, 0x30, 0x78, 0x00},   // U+0034 (4)
    { 0x3F, 0x03, 0x1F, 0x30, 0x30, 0x33, 0x1E, 0x00},   // U+0035 (5)
    { 0x1C, 0x06, 0x03, 0x1F, 0x33, 0x33, 0x1E, 0x00},   // U+0036 (6)
    { 0x3F, 0x33, 0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x00},   // U+0037 (7)
    { 0x1E, 0x33, 0x33, 0x1E, 0x33, 0x33, 0x1E, 0x00},   // U+0038 (8)
    { 0x1E, 0x33, 0x33, 0x3E, 0x30, 0x18, 0x0E, 0x00},   // U+0039 (9)
    { 0x00, 0x0C, 0x0C, 0x00, 0x00, 0x0C, 0x0C, 0x00},   // U+003A (:)
    { 0x00, 0x0C, 0x0C, 0x00, 0x00, 0x0C, 0x0C, 0x06},   // U+003B (;)
    { 0x18, 0x0C, 0x06, 0x03, 0x06, 0x0C, 0x18, 0x00},   // U+003C (<)
    { 0x00, 0x00, 0x3F, 0x00, 0x00, 0x3F, 0x00, 0x00},   // U+003D (=)
    { 0x06, 0x0C, 0x18, 0x30, 0x18, 0x0C, 0x06, 0x00},   // U+003E (>)
    { 0x1E, 0x33, 0x30, 0x18, 0x0C, 0x00, 0x0C, 0x00},   // U+003F (?)
    { 0x3E, 0x63, 0x7B, 0x7B, 0x7B, 0x03, 0x1E, 0x00},   // U+0040 (@)
    { 0x0C, 0x1E, 0x33, 0x33, 0x3F, 0x33, 0x33, 0x00},   // U+0041 (A)
    { 0x3F, 0x66, 0x66, 0x3E, 0x66, 0x66, 0x3F, 0x00},   // U+0042 (B)
    { 0x3C, 0x66, 0x03, 0x03, 0x03, 0x66, 0x3C, 0x00},   // U+0043 (C)
    { 0x1F, 0x36, 0x66, 0x66, 0x66, 0x36, 0x1F, 0x00},   // U+0044 (D)
    { 0x7F, 0x46, 0x16, 0x1E, 0x16, 0x46, 0x7F, 0x00},   // U+0045 (E)
    { 0x7F, 0x46, 0x16, 0x1E, 0x16, 0x06, 0x0F, 0x00},   // U+0046 (F)
    { 0x3C, 0x66, 0x03, 0x03, 0x73, 0x66, 0x7C, 0x00},   // U+0047 (G)
    { 0x33, 0x33, 0x33, 0x3F, 0x33, 0x33, 0x33, 0x00},   // U+0048 (H)
    { 0x1E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00},   // U+0049 (I)
    { 0x78, 0x30, 0x30, 0x30, 0x33, 0x33, 0x1E, 0x00},   // U+004A (J)
    { 0x67, 0x66, 0x36, 0x1E, 0x36, 0x66, 0x67, 0x00},   // U+004B (K)
    { 0x0F, 0x06, 0x06, 0x06, 0x46, 0x66, 0x7F, 0x00},   // U+004C (L)
    { 0x63, 0x77, 0x7F, 0x7F, 0x6B, 0x63, 0x63, 0x00},   // U+004D (M)
    { 0x63, 0x67, 0x6F, 0x7B, 0x73, 0x63, 0x63, 0x00},   // U+004E (N)
    { 0x1C, 0x36, 0x63, 0x63, 0x63, 0x36, 0x1C, 0x00},   // U+004F (O)
    { 0x3F, 0x66, 0x66, 0x3E, 0x06, 0x06, 0x0F, 0x00},   // U+0050 (P)
    { 0x1E, 0x33, 0x33, 0x33, 0x3B, 0x1E, 0x38, 0x00},   // U+0051 (Q)
    { 0x3F, 0x66, 0x66, 0x3E, 0x36, 0x66, 0x67, 0x00},   // U+0052 (R)
    { 0x1E, 0x33, 0x07, 0x0E, 0x38, 0x33, 0x1E, 0x00},   // U+0053 (S)
    { 0x3F, 0x2D, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00},   // U+0054 (T)
    { 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x3F, 0x00},   // U+0055 (U)
    { 0x33, 0x33, 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x00},   // U+0056 (V)
    { 0x63, 0x63, 0x63, 0x6B, 0x7F, 0x77, 0x63, 0x00},   // U+0057 (W)
    { 0x63, 0x63, 0x36, 0x1C, 0x1C, 0x36, 0x63, 0x00},   // U+0058 (X)
    { 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x0C, 0x1E, 0x00},   // U+0059 (Y)
    { 0x7F, 0x63, 0x31, 0x18, 0x4C, 0x66, 0x7F, 0x00},   // U+005A (Z)
    { 0x1E, 0x06, 0x06, 0x06, 0x06, 0x06, 0x1E, 0x00},   // U+005B ([)
    { 0x03, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x40, 0x00},   // U+005C (\)
    { 0x1E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1E, 0x00},   // U+005D (])
    { 0x08, 0x1C, 0x36, 0x63, 0x00, 0x00, 0x00, 0x00},   // U+005E (^)
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF},   // U+005F (_)
    { 0x0C, 0x0C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0060 (`)
    { 0x00, 0x00, 0x1E, 0x30, 0x3E, 0x33, 0x6E, 0x00},   // U+0061 (a)
    { 0x07, 0x06, 0x06, 0x3E, 0x66, 0x66, 0x3B, 0x00},   // U+0062 (b)
    { 0x00, 0x00, 0x1E, 0x33, 0x03, 0x33, 0x1E, 0x00},   // U+0063 (c)
    { 0x38, 0x30, 0x30, 0x3e, 0x33, 0x33, 0x6E, 0x00},   // U+0064 (d)
    { 0x00, 0x00, 0x1E, 0x33, 0x3f, 0x03, 0x1E, 0x00},   // U+0065 (e)
    { 0x1C, 0x36, 0x06, 0x0f, 0x06, 0x06, 0x0F, 0x00},   // U+0066 (f)
    { 0x00, 0x00, 0x6E, 0x33, 0x33, 0x3E, 0x30, 0x1F},   // U+0067 (g)
    { 0x07, 0x06, 0x36, 0x6E, 0x66, 0x66, 0x67, 0x00},   // U+0068 (h)
    { 0x0C, 0x00, 0x0E, 0x0C, 0x0C, 0x0C, 0x1E, 0x00},   // U+0069 (i)
    { 0x30, 0x00, 0x30, 0x30, 0x30, 0x33, 0x33, 0x1E},   // U+006A (j)
    { 0x07, 0x06, 0x66, 0x36, 0x1E, 0x36, 0x67, 0x00},   // U+006B (k)
    { 0x0E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00},   // U+006C (l)
    { 0x00, 0x00, 0x33, 0x7F, 0x7F, 0x6B, 0x63, 0x00},   // U+006D (m)
    { 0x00, 0x00, 0x1F, 0x33, 0x33, 0x33, 0x33, 0x00},   // U+006E (n)
    { 0x00, 0x00, 0x1E, 0x33, 0x33, 0x33, 0x1E, 0x00},   // U+006F (o)
    { 0x00, 0x00, 0x3B, 0x66, 0x66, 0x3E, 0x06, 0x0F},   // U+0070 (p)
    { 0x00, 0x00, 0x6E, 0x33, 0x33, 0x3E, 0x30, 0x78},   // U+0071 (q)
    { 0x00, 0x00, 0x3B, 0x6E, 0x66, 0x06, 0x0F, 0x00},   // U+0072 (r)
    { 0x00, 0x00, 0x3E, 0x03, 0x1E, 0x30, 0x1F, 0x00},   // U+0073 (s)
    { 0x08, 0x0C, 0x3E, 0x0C, 0x0C, 0x2C, 0x18, 0x00},   // U+0074 (t)
    { 0x00, 0x00, 0x33, 0x33, 0x33, 0x33, 0x6E, 0x00},   // U+0075 (u)
    { 0x00, 0x00, 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x00},   // U+0076 (v)
    { 0x00, 0x00, 0x63, 0x6B, 0x7F, 0x7F, 0x36, 0x00},   // U+0077 (w)
    { 0x00, 0x00, 0x63, 0x36, 0x1C, 0x36, 0x63, 0x00},   // U+0078 (x)
    { 0x00, 0x00, 0x33, 0x33, 0x33, 0x3E, 0x30, 0x1F},   // U+0079 (y)
    { 0x00, 0x00, 0x3F, 0x19, 0x0C, 0x26, 0x3F, 0x00},   // U+007A (z)
    { 0x38, 0x0C, 0x0C, 0x07, 0x0C, 0x0C, 0x38, 0x00},   // U+007B ({)
    { 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00},   // U+007C (|)
    { 0x07, 0x0C, 0x0C, 0x38, 0x0C, 0x0C, 0x07, 0x00},   // U+007D (})
    { 0x6E, 0x3B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+007E (~)
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}    // U+007F
};

/**
 * Global Variables
 * 1. window_counter to keep track of windows being created and to assign window_id based on the same.
 * 2. vga_port is the port for vga process
 * 3. msg to receive message from kernel_main 
 * 4. switch_data to save message reference and dereference contents later on.
 * 5. window_array to save messages in an array, since we would not be receiving a lot of messages Array should suffice.
*/
unsigned int window_counter;

PORT vga_port;
VGA_WINDOW_MSG msg;
VGA_WINDOW_MSG* switch_data;

PARAM_VGA_CREATE_WINDOW window_array[MAX_WINDOWS];
/**
 * vga_proc is the monitor process managing ipc and calling helper processes.
 * switch_data is used to pass command in switch statement running in an infinite loop.
**/
void vga_proc(PROCESS self, PARAM param){
  while(1){
      PROCESS vga_process_sender;
      VGA_WINDOW_MSG* switch_data = (VGA_WINDOW_MSG*) receive (&vga_process_sender);
    switch (switch_data->cmd)
    {
    case 0:
      /** create window helper switches function here.
      * Every time a new window is created, the global counter is used to assign a window_id.
      **/
      switch_data->u.create_window.window_id = window_counter;
      create_window_helper(*switch_data);
      break;
    case 1:
      /* text drawing helper function */
      draw_text_helper(*switch_data);
      break;
    case 2:
      /* pixel drawing helper function */
      draw_pixel_helper(*switch_data);  
      break;
    case 3:
      /* line drawing helper function */
      draw_line_helper(*switch_data);
      break;
    default:
      //code will not reach here!
      break;
    }
    /* reply set up for sending window_id */
   reply(vga_process_sender);
  }
  become_zombie();
}

/**
 * init_vga to initial vga process on port.
*/
int init_vga()
{
  int implemented = 1;
  window_counter = 0;
  vga_port = create_process(vga_proc, 7, 0, "vga_process");
  return implemented;
}

/**
 * create_window_helper()
 * param(s): VGA_WINDOW_MSG 
 * Taking the message received from kernel_main() and storing it in an array of window messages.
 * Taking params and drawing borders.
*/
void create_window_helper(VGA_WINDOW_MSG window_message){
  //Storing message in window_array
  window_array[window_counter] = window_message.u.create_window;
  int x_border = window_array[window_counter].x;
  int y_border = window_array[window_counter].y;
  int window_vertical_limit = window_array[window_counter].height;
  int window_horizontal_limit = window_array[window_counter].width;
  char * title = window_array[window_counter].title;

  //drawing vertical borders.
  for(int i = x_border; i <= x_border + window_horizontal_limit; i++){
    poke_b(0xA0000+320*(y_border - 1)+i,0x0F);
    poke_b(0xA0000+320*(y_border + window_vertical_limit + 1)+i,0x0F);
  }
  //drawing horizontal borders.
  for(int i = y_border -1; i <= y_border + window_vertical_limit + 1; i++){
    poke_b(0xA0000+320*i+x_border + 1 + window_horizontal_limit,0x0F);  
    poke_b(0xA0000+320*(i)+ x_border - 1,0x0F);
  }
  //drawing top border for title 10 x window_horizontal_limit.
  for(int i = y_border - 2; i >= y_border - 10; i--){
    for(int j = x_border - 1; j <= x_border + window_horizontal_limit + 1; j++){
         poke_b(0xA0000+320*i + j,0x0F);  
    }
  }
  //drawing title using helper draw_char
  for (int i =0;i< k_strlen(title);i++){
    draw_char(title[i],0,0x0f,x_border +2+i*8,y_border-8,0);
  }
  //increasing window counter on each new window.
  window_counter++;
}

/**
 * draw_text_helper()
 * param(s): VGA_WINDOW_MSG 
 * Taking the message received from kernel_main() and accessing the message using window_id taken from messages.
 * base_address is taken from window x and y then text is drawn in reference to base address.
 * All drawing is done in helper function draw_text and x is incremented 8 times to keep space among characters.
*/
void draw_text_helper(VGA_WINDOW_MSG text_message){
  //window_id taken from window message and window parameters for base address calculation.
  int w_id = text_message.u.draw_text.window_id;
  int x_window = window_array[w_id].x;
  int y_window = window_array[w_id].y;
  //base address calculation
  int base_address = x_window + y_window*320;
  //all attributes of text taken from message
  int x = text_message.u.draw_text.x;
  int y = text_message.u.draw_text.y;
  int fgcolor = text_message.u.draw_text.fg_color;
  int bgcolor = text_message.u.draw_text.bg_color;
  //text array to be passed for drawing.
  char* text = text_message.u.draw_text.text;
  for(int i = 0; i<k_strlen(text);i++){
    //window clipping, the +16 is for space character which had issues with window border on the right.
    if(x + 16>= x_window + window_array[w_id].width)
      break;
    draw_char(text[i], fgcolor, bgcolor,x,y,base_address);
    x+= 8;
  }
} 

/**
 * draw_line_helper()
 * param(s): VGA_WINDOW_MSG 
 * Taking the message received from kernel_main() and using it to calculate relative address for line.
 * Taking params and drawing borders.
*/
void draw_line_helper(VGA_WINDOW_MSG line_message){
  {          
    /**
     * Mid-Point Line Generation Algorithm, referenced from 
     * https://www.csee.umbc.edu/~rheingan/435/pages/res/gen-2.Lines-single-page-0.html
     * step is slope, dx and dy are used for calculating step at each pixel
    /* taking window pixels and calculating base address for line plotting. */
    int w_id = line_message.u.draw_line.window_id;
    int x_window = window_array[w_id].x;
    int y_window = window_array[w_id].y;
    /* base Address */
    int base_address = x_window + y_window*320;
    int x_end,y_end,x_start,y_start,i;               
    int x,y;
    /* line color */
    char* line_color = line_message.u.draw_pixel.color;
    int dx,dy,step;             
    /* start and end coordinates of the line */
    x_start = line_message.u.draw_line.x0; 
    y_start = line_message.u.draw_line.y0;
    x_end =  line_message.u.draw_line.x1;
    y_end =  line_message.u.draw_line.y1;
    /* slope calculation */
    dx = x_end - x_start;
    dy = y_end - y_start;
    step = dy - (dx/2);
    x = x_start-1,y = y_start-1;
    /*if x slope is greater and point is */
    while (x<x_end && dx>=dy)
    {
      x++;
      /* slope adjustment */
      if(step<0){
        step = step + dy;
      }
      else 
      {
        step +=(dy-dx);
        y++;
      }
      plot_pixel(x,y,base_address,line_color);
    }

    dx = x_start - x_end;
    dy = y_end - y_start;
    step = dy - (dx/2);
    x = x_start+1,y = y_start-1;
    /**
     * for negative quadrats where x exceeds the endpoint on screen
    */
    while (x>x_end && dx>=dy)
    {
      x--;
      /* code */
      if(step<0){
        step = step + dy;
      }
      else 
      {
        step +=(dy-dx);
        y++;
      }
      plot_pixel(x,y,base_address,line_color);
    }
    /**
     * change roles of x and y, draw from x_end.
    */
    dx = x_end > x_start ? x_end - x_start : x_start - x_end;
    dy = y_end - y_start;
    step = dx - (dy/2);
    x = x_end > x_start ? x_start-1 : x_start + 1;
    y = y_start-1;
    while (y<y_end && dy>dx)
    {
      y++;
      if(step<0){
        step = step + dx;
      }
      else 
      {
        step +=(dx-dy);
        x_end > x_start ? x++ : x--;
      }
      plot_pixel(x,y,base_address,line_color);
    }
  }
}

/**
 * draw_pixel_helper()
 * param(s): VGA_WINDOW_MSG 
 * Taking the message received from kernel_main() and using it to calculate relative address for a pixel.
 * Taking params and drawing borders.
*/
void draw_pixel_helper(VGA_WINDOW_MSG pixel_message){
  
  char pixel_color = pixel_message.u.draw_pixel.color;
  int x = pixel_message.u.draw_pixel.x;
  int y = pixel_message.u.draw_pixel.y;
  int pixel_location = y*320 + x;
  //window base address taken from window_array using window_id as w_id
  int w_id = pixel_message.u.draw_pixel.window_id;
  int x_window = window_array[w_id].x;
  int y_window = window_array[w_id].y;
  int base_address = x_window + y_window*320;
  poke_b (0xA0000 + base_address  + pixel_location , pixel_color);
}

/**
 * This is an extra helper function for text drawing.
 * bitmap is reference from above in file, x_char and y_char are iterators for char position.
 * The char drawing is referenced from https://wiki.osdev.org/VGA_Fonts
 * glyph has letter information, mask has bit masking information.
 * fgcolor and bgcolor get picked up on the basis of presence of pixel.
*/
void draw_char(unsigned char c,int fgcolor, int bgcolor, int x, int y, int base_address){
  char *bitmap = font8x8_basic;
  int x_char,y_char;
	int mask[8]={1,2,4,8,16,32,64,128};
	unsigned char *gylph=bitmap+(int)c*8;
	for(y_char=0;y_char<8;y_char++){
		for(x_char=0;x_char<8;x_char++){
			plot_pixel(x+x_char,y+y_char,base_address,gylph[y_char]&mask[x_char]?fgcolor:bgcolor);
		}
	}
}

/**
 * This is an extra helper function for line and text drawing.
*/
void plot_pixel(int x, int y, int base_address, char* pixel_color){
  int pixel_location = (y*320) + x;
  poke_b ((0xA0000 + pixel_location + base_address), pixel_color);
}
